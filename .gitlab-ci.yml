stages:
  - build
  - test
  - release
  - build-gfz-image
  - deploy-gfz-image
  - after-deployment-gfz
  - after-deployment-test-gfz

variables:
  CONTAINER_TEST_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME
  CONTAINER_RELEASE_IMAGE: $CI_REGISTRY_IMAGE:latest

build-image:
  stage: build
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  script:
    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" > /kaniko/.docker/config.json
    - /kaniko/executor --context $CI_PROJECT_DIR --dockerfile $CI_PROJECT_DIR/Dockerfile --destination $CONTAINER_TEST_IMAGE
  except:
    variables:
      - $STAGING_HOST =~ /gfz/

Linting-code:
  stage: test
  image: $CI_REGISTRY_IMAGE
  before_script:
    - pip install --upgrade setuptools
    - pip install --upgrade flake8
  script:
    - flake8 $CI_PROJECT_DIR/app/project
  except:
    variables:
      - $STAGING_HOST =~ /gfz/

test-image:
  stage: test
  script:
    - echo "This is just dummy test - waitting for the databse connection."
  except:
    variables:
      - $STAGING_HOST =~ /gfz/

release-image:
  stage: release
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  script:
    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" > /kaniko/.docker/config.json
    - echo "FROM  ${CONTAINER_TEST_IMAGE}" | /kaniko/executor --context $CI_PROJECT_DIR --dockerfile /dev/stdin --destination ${CONTAINER_RELEASE_IMAGE}
  only:
    - master
  except:
    variables:
      - $STAGING_HOST =~ /gfz/


.docker_login_gitlab_registry: &docker_login_gitlab_registry
  - echo "$CI_BUILD_TOKEN" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY

build-gfz-image:
  stage: build-gfz-image
  image: docker:19.03.1
  environment:
    name: gfzstaging
    url: https://$STAGING_HOST
  before_script:
    - *docker_login_gitlab_registry
  script:
    - >
      if [ -z "$CI_COMMIT_TAG" ]; then
        docker build --tag "$CI_REGISTRY_IMAGE:latest" -f Dockerfile .
        docker push "$CI_REGISTRY_IMAGE:latest"
      else
        docker build --tag "$CI_REGISTRY_IMAGE:$CI_COMMIT_TAG" --tag "$CI_REGISTRY_IMAGE:latest" -f Dockerfile .
        docker push "$CI_REGISTRY_IMAGE:latest"
        docker push "$CI_REGISTRY_IMAGE:$CI_COMMIT_TAG"
      fi
  tags:
    - deploy
    - staging
    - id2
  only:
    variables:
      - $STAGING_HOST =~ /gfz/
  when: manual
  allow_failure: true

deploy-gfz-image:
  stage: deploy-gfz-image
  environment:
    name: gfzstaging
    url: https://$STAGING_HOST
  tags:
    - deploy
    - staging
    - id2
  variables:
    COMPOSE_PROJECT_NAME: ssmbackend
  before_script:
    - *docker_login_gitlab_registry
  script:
    - docker-compose -f docker/deployment/gfz/staging/docker-compose.yml pull
    - docker-compose -f docker/deployment/gfz/staging/docker-compose.yml up -d
  only:
    variables:
      - $STAGING_HOST =~ /gfz/
  when: manual
  dependencies:
    - build-gfz-image
  allow_failure: true


after-deploy-gfz-image:
  stage: after-deployment-gfz
  environment:
    name: gfzstaging
    url: https://$STAGING_HOST
  tags:
    - deploy
    - staging
    - id2
  variables:
    COMPOSE_PROJECT_NAME: ssmbackend
  before_script:
    - *docker_login_gitlab_registry
  script:
    - docker-compose -f docker/deployment/gfz/staging/docker-compose.yml exec db psql -U postgres 'CREATE DATABASE db_prod; CREATE DATABASE db_dev; CREATE DATABASE db_test;' || echo "Databases already existing"
  only:
    variables:
      - $STAGING_HOST =~ /gfz/
  when: manual
  dependencies:
    - deploy-gfz-image
  allow_failure: true

test-availability:
  stage: after-deployment-test-gfz
  image: python:3
  environment:
    name: gfzstaging
    url: https://$STAGING_HOST
  tags:
    - deploy
    - staging
    - id2
  script:
    - curl http://$STAGING_HOST:5000/sis/v1/ping
  only:
    variables:
      - $STAGING_HOST =~ /gfz/
  when: manual
  dependencies:
    - after-deploy-gfz-image
  allow_failure: true
